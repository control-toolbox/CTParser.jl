using CTParser
using CTModels
using CTBase

CTParser.prefix!(:CTModels) # code generated by @def is prefixed by CTModels (not by OptimalControl - the default) for tests
CTParser.e_prefix!(:CTBase) # exceptions in code generated by @def are prefixed by CTBase (not by OptimalControl - the default) for tests

# ------------------------------------------
# Goddard problem parameters

# Parameters
const t0 = 0      # initial time
const r0 = 1      # initial altitude
const v0 = 0      # initial speed
const m0 = 1      # initial mass
const vmax = 0.1  # maximal authorized speed
const mf = 0.6    # final mass to target

# Dynamics
const Cd = 310
const Tmax = 3.5
const β = 500
const b = 2

F0(x) = begin
    r, v, m = x
    D = Cd * v^2 * exp(-β*(r - 1)) # Drag force
    return [v, -D/m - 1/r^2, 0]
end

F1(x) = begin
    r, v, m = x
    return [0, Tmax/m, -b*Tmax]
end

# ------------------------------------------
e = quote
    tf ∈ R, variable
    t ∈ [t0, tf], time
    x = (r, v, m) ∈ R³, state
    u ∈ R, control

    x(t0) == [r0, v0, m0]
    m(tf) == mf,         (1)
    0 ≤ u(t) ≤ 1
    r(t) ≥ r0
    0 ≤ v(t) ≤ vmax
    PRAGMA(1+1)

    ẋ(t) == F0(x(t)) + u(t) * F1(x(t))

    r(tf) → max
end;

code = CTParser.order(e)
o = eval(CTParser.def_fun(code))

# Wrong order
e = quote
    u ∈ R, control
    x(t0) == [r0, v0, m0]
    r(tf) → max
    x = (r, v, m) ∈ R³, state
    t ∈ [t0, tf], time
    m(tf) == mf,         (1)
    0 ≤ u(t) ≤ 1
    r(t) ≥ r0
    0 ≤ v(t) ≤ vmax
    ẋ(t) == F0(x(t)) + u(t) * F1(x(t))
    PRAGMA(1+1)
    tf ∈ R, variable
end;

code = CTParser.order(e)
o = eval(CTParser.def_fun(code))
