var documenterSearchIndex = {"docs":
[{"location":"defaults.html#Private-API","page":"Defaults","title":"Private API","text":"This page lists non-exported (internal) symbols of CTParser.\n\n","category":"section"},{"location":"defaults.html#From-CTParser","page":"Defaults","title":"From CTParser","text":"","category":"section"},{"location":"defaults.html#__default_backend_exa","page":"Defaults","title":"__default_backend_exa","text":"","category":"section"},{"location":"defaults.html#__default_base_type_exa","page":"Defaults","title":"__default_base_type_exa","text":"","category":"section"},{"location":"defaults.html#__default_e_prefix","page":"Defaults","title":"__default_e_prefix","text":"","category":"section"},{"location":"defaults.html#__default_grid_size_exa","page":"Defaults","title":"__default_grid_size_exa","text":"","category":"section"},{"location":"defaults.html#__default_init_exa","page":"Defaults","title":"__default_init_exa","text":"","category":"section"},{"location":"defaults.html#__default_parsing_backend","page":"Defaults","title":"__default_parsing_backend","text":"","category":"section"},{"location":"defaults.html#__default_prefix_exa","page":"Defaults","title":"__default_prefix_exa","text":"","category":"section"},{"location":"defaults.html#__default_prefix_fun","page":"Defaults","title":"__default_prefix_fun","text":"","category":"section"},{"location":"defaults.html#__default_scheme_exa","page":"Defaults","title":"__default_scheme_exa","text":"","category":"section"},{"location":"defaults.html#CTParser.__default_backend_exa","page":"Defaults","title":"CTParser.__default_backend_exa","text":"__default_backend_exa()\n\n\nReturn the default ExaModels backend, if any.\n\nWhen this is nothing, no specific ExaModels backend is selected by default and the library's own defaults are used instead.\n\nReturns\n\nUnion{Nothing,Symbol}: name of the default ExaModels backend, or nothing if the generic backend should be used.\n\nExample\n\njulia> using CTParser\n\njulia> CTParser.__default_backend_exa()\nnothing\n\n\n\n\n\n","category":"function"},{"location":"defaults.html#CTParser.__default_base_type_exa","page":"Defaults","title":"CTParser.__default_base_type_exa","text":"__default_base_type_exa() -> Type{Float64}\n\n\nReturn the default base scalar type used for ExaModels discretisations.\n\nThis type is used for the floating-point data stored in the underlying problems.\n\nReturns\n\nDataType: default scalar type (currently Float64).\n\nExample\n\njulia> using CTParser\n\njulia> CTParser.__default_base_type_exa()\nFloat64\n\n\n\n\n\n","category":"function"},{"location":"defaults.html#CTParser.__default_e_prefix","page":"Defaults","title":"CTParser.__default_e_prefix","text":"__default_e_prefix() -> Symbol\n\n\nReturn the default prefix for error-handling utilities.\n\nThe prefix identifies the module that defines error types and exceptions used when reporting parsing and modelling issues.\n\nReturns\n\nSymbol: name of the default error-handling module (currently :CTBase).\n\nExample\n\njulia> using CTParser\n\njulia> CTParser.__default_e_prefix()\n:CTBase\n\n\n\n\n\n","category":"function"},{"location":"defaults.html#CTParser.__default_grid_size_exa","page":"Defaults","title":"CTParser.__default_grid_size_exa","text":"__default_grid_size_exa() -> Int64\n\n\nReturn the default grid size used for ExaModels discretisations.\n\nThis is the number of time intervals used when constructing the discretised optimal control problem.\n\nReturns\n\nInt: default grid size (currently 250).\n\nExample\n\njulia> using CTParser\n\njulia> CTParser.__default_grid_size_exa()\n250\n\n\n\n\n\n","category":"function"},{"location":"defaults.html#CTParser.__default_init_exa","page":"Defaults","title":"CTParser.__default_init_exa","text":"__default_init_exa() -> Tuple{Float64, Float64, Float64}\n\n\nReturn the default initial values used for ExaModels problems.\n\nThe tuple typically corresponds to initial guesses for the state, control and additional variables when no user-specified initialisation is provided.\n\nReturns\n\nTuple: default initial values (currently (0.1, 0.1, 0.1)).\n\nExample\n\njulia> using CTParser\n\njulia> CTParser.__default_init_exa()\n(0.1, 0.1, 0.1)\n\n\n\n\n\n","category":"function"},{"location":"defaults.html#CTParser.__default_parsing_backend","page":"Defaults","title":"CTParser.__default_parsing_backend","text":"__default_parsing_backend() -> Symbol\n\n\nReturn the default parsing backend used by @def.\n\nThis controls whether the parser targets the functional (:fun) or another backend. In the current implementation the default is :fun.\n\nReturns\n\nSymbol: name of the default parsing backend.\n\nExample\n\njulia> using CTParser\n\njulia> CTParser.__default_parsing_backend()\n:fun\n\n\n\n\n\n","category":"function"},{"location":"defaults.html#CTParser.__default_prefix_exa","page":"Defaults","title":"CTParser.__default_prefix_exa","text":"__default_prefix_exa() -> Symbol\n\n\nReturn the default prefix for ExaModels backends.\n\nThe prefix identifies the module that provides the ExaModels-based discretisation support used when the :exa backend is active.\n\nReturns\n\nSymbol: name of the default ExaModels backend module (currently :ExaModels).\n\nExample\n\njulia> using CTParser\n\njulia> CTParser.__default_prefix_exa()\n:ExaModels\n\n\n\n\n\n","category":"function"},{"location":"defaults.html#CTParser.__default_prefix_fun","page":"Defaults","title":"CTParser.__default_prefix_fun","text":"__default_prefix_fun() -> Symbol\n\n\nReturn the default prefix for functional backends.\n\nThe prefix identifies the module that provides the PreModel and associated routines used by the @def macro in functional mode.\n\nReturns\n\nSymbol: name of the default functional backend module (currently :CTModels).\n\nExample\n\njulia> using CTParser\n\njulia> CTParser.__default_prefix_fun()\n:CTModels\n\n\n\n\n\n","category":"function"},{"location":"defaults.html#CTParser.__default_scheme_exa","page":"Defaults","title":"CTParser.__default_scheme_exa","text":"__default_scheme_exa() -> Symbol\n\n\nReturn the default collocation scheme used for ExaModels backends.\n\nThe symbol identifies the time-discretisation scheme to be used when building ExaModels-based formulations.\n\nReturns\n\nSymbol: name of the default ExaModels scheme (currently :midpoint).\n\nExample\n\njulia> using CTParser\n\njulia> CTParser.__default_scheme_exa()\n:midpoint\n\n\n\n\n\n","category":"function"},{"location":"initial_guess.html#Private-API","page":"Initial Guess","title":"Private API","text":"This page lists non-exported (internal) symbols of CTParser.\n\n","category":"section"},{"location":"initial_guess.html#From-CTParser","page":"Initial Guess","title":"From CTParser","text":"","category":"section"},{"location":"initial_guess.html#@init","page":"Initial Guess","title":"@init","text":"","category":"section"},{"location":"initial_guess.html#INIT_PREFIX","page":"Initial Guess","title":"INIT_PREFIX","text":"","category":"section"},{"location":"initial_guess.html#__default_init_prefix","page":"Initial Guess","title":"__default_init_prefix","text":"","category":"section"},{"location":"initial_guess.html#_collect_init_specs","page":"Initial Guess","title":"_collect_init_specs","text":"","category":"section"},{"location":"initial_guess.html#init_fun","page":"Initial Guess","title":"init_fun","text":"","category":"section"},{"location":"initial_guess.html#init_prefix","page":"Initial Guess","title":"init_prefix","text":"","category":"section"},{"location":"initial_guess.html#init_prefix!","page":"Initial Guess","title":"init_prefix!","text":"","category":"section"},{"location":"initial_guess.html#CTParser.@init","page":"Initial Guess","title":"CTParser.@init","text":"@init ocp begin\n    ...\nend\n\nBuild an initial guess object for an optimal control problem from a small initialisation DSL.\n\nThe block following @init is interpreted as a collection of assignment rules for the state, control and variable components of an optimal control problem, using a compact syntax of the form\n\nq(t) := sin(t)     # time-dependent function\nx(T) := X          # time grid and associated samples\nu := 0.1           # constant value\na = 1.0           # ordinary Julia alias (not part of the initial guess)\nv(t) := a         # time-dependent function using the alias above\n\nThe macro itself only rewrites this DSL into a NamedTuple-based representation. All dimensional checks, interpretation of aliases and construction of the concrete initial guess object are delegated to the backend selected by init_prefix (by défaut :CTModels), via build_initial_guess and validate_initial_guess.\n\nAn optional keyword-like trailing argument controls logging:\n\nig = @init ocp begin\n    u(t) := t\nend log = true\n\nWhen log = true, the macro additionally prints a human-readable NamedTuple-like representation of the specification.\n\nArguments\n\nocp: symbolic optimal control problem built with @def.\nbegin ... end: block containing the initialisation DSL.\nlog: optional Boolean keyword (default false) enabling textual logging of the parsed specification.\n\nReturns\n\nAbstractOptimalControlInitialGuess: backend-specific initial guess object produced by the current backend (par défaut CTModels).\n\nExample\n\njulia> using CTParser\n\njulia> ocp = @def begin\n           t ∈ [0, 1], time\n           x ∈ R, state\n           u ∈ R, control\n           ẋ(t) == u(t)\n           x(0) == 0\n           x(1) == 0\n           ∫(0.5u(t)^2) → min\n       end\n\njulia> ig = @init ocp begin\n           u(t) := t\n       end\n\njulia> ig isa CTModels.AbstractOptimalControlInitialGuess\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"initial_guess.html#CTParser.INIT_PREFIX","page":"Initial Guess","title":"CTParser.INIT_PREFIX","text":"Current backend prefix used by @init.\n\nThis reference stores the symbol of the backend module that provides build_initial_guess and validate_initial_guess. It is initialised by __default_init_prefix and can be updated at runtime via init_prefix!.\n\n\n\n\n\n","category":"constant"},{"location":"initial_guess.html#CTParser.__default_init_prefix","page":"Initial Guess","title":"CTParser.__default_init_prefix","text":"__default_init_prefix() -> Symbol\n\n\nReturn the default backend prefix used by @init.\n\nThe returned symbol identifies the module that implements build_initial_guess and validate_initial_guess. In the current implementation this is :CTModels.\n\nReturns\n\nSymbol: name of the default backend module.\n\nExample\n\njulia> using CTParser\n\njulia> CTParser.__default_init_prefix()\n:CTModels\n\n\n\n\n\n","category":"function"},{"location":"initial_guess.html#CTParser._collect_init_specs","page":"Initial Guess","title":"CTParser._collect_init_specs","text":"_collect_init_specs(\n    ex\n) -> Tuple{Vector{Expr}, Vector{Symbol}, Vector{Any}}\n\n\nInternal helper that parses the body of an @init block.\n\nThe function walks through the expression ex and splits it into\n\nalias statements, which are left as ordinary Julia assignments and executed verbatim inside the generated block;\ninitialisation specifications of the form lhs := rhs or lhs(t) := rhs / lhs(T) := rhs, which are converted into keys and values used to build a NamedTuple.\n\nArguments\n\nex::Any: expression or block coming from the body of @init.\n\nReturns\n\nalias_stmts::Vector{Expr}: ordinary statements to execute before building the initial guess.\nkeys::Vector{Symbol}: names of the components being initialised (e.g. :q, :v, :u, :tf).\nvals::Vector{Any}: expressions representing the corresponding values, functions or (T, data) pairs.\n\n\n\n\n\n","category":"function"},{"location":"initial_guess.html#CTParser.init_fun","page":"Initial Guess","title":"CTParser.init_fun","text":"init_fun(ocp, e) -> Tuple{String, Expr}\n\n\nLowering function used by @init to build the expanded code.\n\nGiven an optimal control problem ocp and the body e of an @init block, this function collects the initialisation specifications, builds an appropriate NamedTuple expression and constructs the call to build_initial_guess / validate_initial_guess on the current backend (prefix returned by init_prefix).\n\nIt also produces a compact string representation of the specification, used for optional logging when log = true is requested at the macro level.\n\nArguments\n\nocp: symbolic optimal control problem built with @def.\ne: expression corresponding to the body of the @init block.\n\nReturns\n\nlog_str::String: human-readable NamedTuple-like description of the specification.\ncode_expr::Expr: block of Julia code that builds and validates the initial guess when executed.\n\n\n\n\n\n","category":"function"},{"location":"initial_guess.html#CTParser.init_prefix","page":"Initial Guess","title":"CTParser.init_prefix","text":"init_prefix() -> Symbol\n\n\nReturn the current backend prefix used by @init.\n\nThis is the symbol of the module that will be used to interpret the NamedTuple produced by the initialisation DSL, typically :CTModels.\n\nReturns\n\nSymbol: name of the backend module currently used by @init.\n\nExample\n\njulia> using CTParser\n\njulia> CTParser.init_prefix()\n:CTModels\n\n\n\n\n\n","category":"function"},{"location":"initial_guess.html#CTParser.init_prefix!","page":"Initial Guess","title":"CTParser.init_prefix!","text":"init_prefix!(p)\n\n\nSet the backend prefix used by @init.\n\nThis function updates the global INIT_PREFIX, thereby changing which module is used to build and validate initial guesses.\n\nArguments\n\np::Symbol: name of the backend module to use (e.g. :CTModels).\n\nReturns\n\nNothing.\n\nExample\n\njulia> using CTParser\n\njulia> old = CTParser.init_prefix();\n\njulia> CTParser.init_prefix!(:MyBackend)\n\njulia> CTParser.init_prefix()\n:MyBackend\n\njulia> CTParser.init_prefix!(old);  # restore\n\n\n\n\n\n","category":"function"},{"location":"index.html#CTParser.jl","page":"Introduction","title":"CTParser.jl","text":"The CTParser.jl package is part of the control-toolbox ecosystem.\n\nnote: Note\nThe root package is OptimalControl.jl which aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods, both on CPU and GPU.\n\nwarning: Warning\nIn some examples in the documentation, private methods are shown without the module prefix. This is done for the sake of clarity and readability.julia> using CTParser\njulia> x = 1\njulia> private_fun(x) # throws an errorThis should instead be written as:julia> using CTParser\njulia> x = 1\njulia> CTParser.private_fun(x)If the method is re-exported by another package,module OptimalControl\n    import CTParser: private_fun\n    export private_fun\nendthen there is no need to prefix it with the original module name:julia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"section"},{"location":"index.html#What-CTParser-provides","page":"Introduction","title":"What CTParser provides","text":"At a high level, CTParser.jl is responsible for turning a compact, mathematical DSL into executable Julia code for the rest of the ecosystem (in particular CTModels.jl and ExaModels.jl). It does not solve optimal control problems by itself; instead, it focuses on parsing and code generation.\n\nThe two main entry points are:\n\n@def macro – define an optimal control problem from a human-readable specification.\n@init macro – define an initial guess for state, control and variables using a small initialisation DSL.","category":"section"},{"location":"index.html#The-@def-macro-and-its-backends","page":"Introduction","title":"The @def macro and its backends","text":"The macro\n\nocp = @def begin\n    # symbolic definition of an OCP\nend\n\nparses the block and builds an intermediate representation of the optimal control problem. Internally, @def can target different backends:\n\nthe functional backend :fun (default), where the OCP is represented by a CTModels.Model and evaluated through Julia functions;\nthe ExaModels backend :exa, where the same symbolic description is lowered to an ExaModels.ExaModel suitable for large-scale NLP solvers.\n\nThe active backends and their prefixes are controlled by prefix_fun(), prefix_exa() and the corresponding setters. This allows other packages (such as OptimalControl.jl) to plug in custom model types while reusing the same parsing layer.","category":"section"},{"location":"index.html#The-@init-macro-for-initial-guesses","page":"Introduction","title":"The @init macro for initial guesses","text":"The macro\n\nig = @init ocp begin\n    # initialisation DSL\nend\n\nprovides a compact way of building initial guesses for an OCP. The block can mix:\n\ntime-dependent functions, e.g. u(t) := t or x(t) := [sin(t), 1];\ntime grids, e.g. x(T) := X where T is a vector of times and X samples along the trajectory;\nconstants and aliases, e.g. a = 1.0; v(t) := a or tf := 1.0.\n\n@init itself only rewrites this DSL into a NamedTuple of symbolic specifications. The actual construction and validation of a backend-specific initial guess object is delegated to the module selected by init_prefix() (by défaut CTModels), via build_initial_guess et validate_initial_guess.","category":"section"},{"location":"utils.html#Private-API","page":"Utils","title":"Private API","text":"This page lists non-exported (internal) symbols of CTParser.\n\n","category":"section"},{"location":"utils.html#From-CTParser","page":"Utils","title":"From CTParser","text":"","category":"section"},{"location":"utils.html#__symgen","page":"Utils","title":"__symgen","text":"","category":"section"},{"location":"utils.html#as_range","page":"Utils","title":"as_range","text":"","category":"section"},{"location":"utils.html#concat","page":"Utils","title":"concat","text":"","category":"section"},{"location":"utils.html#constraint_type","page":"Utils","title":"constraint_type","text":"","category":"section"},{"location":"utils.html#expr_it","page":"Utils","title":"expr_it","text":"","category":"section"},{"location":"utils.html#has","page":"Utils","title":"has","text":"","category":"section"},{"location":"utils.html#is_range","page":"Utils","title":"is_range","text":"","category":"section"},{"location":"utils.html#replace_call","page":"Utils","title":"replace_call","text":"","category":"section"},{"location":"utils.html#subs","page":"Utils","title":"subs","text":"","category":"section"},{"location":"utils.html#subs2","page":"Utils","title":"subs2","text":"","category":"section"},{"location":"utils.html#subs2m","page":"Utils","title":"subs2m","text":"","category":"section"},{"location":"utils.html#subs3","page":"Utils","title":"subs3","text":"","category":"section"},{"location":"utils.html#CTParser.__symgen","page":"Utils","title":"CTParser.__symgen","text":"__symgen(s...) -> Any\n\n\nGenerate a fresh symbol by concatenating the given components and a gensym() suffix.\n\nThis is used throughout the parser to create unique internal names that do not collide with user-defined identifiers.\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTParser.as_range","page":"Utils","title":"CTParser.as_range","text":"as_range(x) -> Any\n\n\nReturn x itself if it is a range, or a one-element array [x].\n\nThis is a normalisation helper used when interpreting constraint indices.\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTParser.concat","page":"Utils","title":"CTParser.concat","text":"concat(e1, e2) -> Expr\n\n\nConcatenate two expressions without creating extra blocks (as Expr(:block, e1, e2) would do).\n\nExample\n\njulia> e1 = :(x = 1; y = 2)\nquote\n    x = 1\n    #= REPL[3]:1 =#\n    y = 2\nend\n\njulia> e2 = :(z = 3)\n:(z = 3)\n\njulia> concat(e1, e2)\nquote\n    x = 1\n    #= REPL[3]:1 =#\n    y = 2\n    z = 3\nend\n\njulia> concat(e1, e1)\nquote\n    x = 1\n    #= REPL[3]:1 =#\n    y = 2\n    x = 1\n    #= REPL[3]:1 =#\n    y = 2\nend\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTParser.constraint_type","page":"Utils","title":"CTParser.constraint_type","text":"constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u,\n    v\n) -> Union{Symbol, Tuple{Symbol, Any}}\n\n\nReturn the type constraint among :initial, :final, :boundary, :control_range, :control_fun, :state_range, :state_fun, :mixed, :variable_range, :variable_fun (:other otherwise), together with the appropriate value (range, updated expression...) Expressions like u(t0) where u is the control and t0 the initial time return :other.\n\nExample\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v\n\njulia> constraint_type(:( ẏ(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( ẋ(s) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( x(0)' ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(t)' ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( x(0) ), t, t0, tf, x, u, v)\n(:initial, nothing)\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)\n(:initial, 1)\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(tf) ), t, t0, tf, x, u, v)\n(:final, nothing)\nj\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)\n(:final, 1)\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)\n(:control_range, 1)\n\njulia> constraint_type(:( u(t) ), t, t0, tf, x, u, v)\n(:control_range, nothing)\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)\n:control_fun\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)\n(:state_range, 1)\n\njulia> constraint_type(:( x(t) ), t, t0, tf, x, u, v)\n(:state_range, nothing)\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:2:9)\n\njulia> constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:10)\n\njulia> constraint_type(:( v[2] ), t, t0, tf, x, u, v)\n(:variable_range, 2)\n\njulia> constraint_type(:( v ), t, t0, tf, x, u, v)\n(:variable_range, nothing)\n\njulia> constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)\n:variable_fun\njulia> constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)\n:variable_fun\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTParser.expr_it","page":"Utils","title":"CTParser.expr_it","text":"expr_it(e, _Expr, f) -> Any\n\n\nExpr iterator: apply _Expr to nodes and f to leaves of the AST.\n\nExample\n\njulia> id(e) = expr_it(e, Expr, x -> x)\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTParser.has","page":"Utils","title":"CTParser.has","text":"has(e, e1) -> Union{Missing, Bool}\n\n\nReturn true if e contains e1.\n\nExample\n\njulia> e = :( ∫( x[1](t)^2 + 2*u(t) ) → min )\n:(∫((x[1])(t) ^ 2 + 2 * u(t)) → min)\n\njulia> has(e, 2)\ntrue\n\njulia> has(e, :x)\ntrue\n\njulia> has(e, :min)\ntrue\n\njulia> has(e, :( x[1](t)^2 ))\ntrue\n\njulia> !has(e, :( x[1](t)^3 ))\ntrue\n\njulia> !has(e, 3)\ntrue\n\njulia> !has(e, :max)\ntrue\n\njulia> has(:x, :x)\ntrue\n\njulia> !has(:x, 2)\ntrue\n\njulia> !has(:x, :y)\ntrue\n\n\n\n\n\nhas(e, x, t) -> Union{Missing, Bool}\n\n\nReturn true if e contains a (...x...)(t) call.\n\nExample\n\njulia> e = :( ∫( x[1](t)^2 + 2*u(t) ) → min )\n:(∫((x[1])(t) ^ 2 + 2 * u(t)) → min)\n\njulia> has(e, :x, :t)\ntrue\n\njulia> has(e, :u, :t)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTParser.is_range","page":"Utils","title":"CTParser.is_range","text":"is_range(x) -> Union{Missing, Bool}\n\n\nReturn true if x represents a range.\n\nThis predicate is specialised for AbstractRange values and for expressions of the form i:j or i:p:j.\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTParser.replace_call","page":"Utils","title":"CTParser.replace_call","text":"replace_call(e, x::Symbol, t, y) -> Any\n\n\nReplace calls in e of the form (...x...)(t) by (...y...).\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2 ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2)\n\n\n\n\n\nreplace_call(e, x::Vector{Symbol}, t, y) -> Any\n\n\nReplace calls in e of the form (...x1...x2...)(t) by (...y1...y2...) for all symbols x1, x2... in the vector x.\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:((xx ^ 2)(t0) + uu[1])\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTParser.subs","page":"Utils","title":"CTParser.subs","text":"subs(e, e1::Union{Real, Symbol}, e2) -> Any\n\n\nSubstitute expression e1 by expression e2 in expression e.\n\nExamples\n\njulia> e = :( ∫( r(t)^2 + 2u₁(t)) → min )\n:(∫(r(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> subs(e, :r, :( x[1] ))\n:(∫((x[1])(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> e = :( ∫( u₁(t)^2 + 2u₂(t)) → min )\n:(∫(u₁(t) ^ 2 + 2 * u₂(t)) → min)\n\njulia> for i ∈ 1:2\n       e = subs(e, Symbol(:u, Char(8320+i)), :( u[$i] ))\n       end; e\n:(∫((u[1])(t) ^ 2 + 2 * (u[2])(t)) → min)\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); subs(e, :( $x[1]($(t0)) ), :( $x0[1] ))\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTParser.subs2","page":"Utils","title":"CTParser.subs2","text":"subs2(e, x, y, j; k) -> Any\n\n\nSubstitute occurrences of symbol x in expression e with indexed access to y at time index j. Handles two patterns:\n\nx[i] (scalar index) → y[i, j]\nx[1:3] (range index) → [y[k, j] for k ∈ 1:3]\n\nSee also: subs2m.\n\nExamples\n\njulia> # Scalar indexing\njulia> e = :(x0[1] * 2xf[3] - cos(xf[2]) * 2x0[2])\njulia> subs2(subs2(e, :x0, :x, 0), :xf, :x, :N)\n:(x[1, 0] * (2 * x[3, N]) - cos(x[2, N]) * (2 * x[2, 0]))\n\njulia> # Range indexing\njulia> e = :(x0[1:3])\njulia> subs2(e, :x0, :x, 0; k = :k)\n:([x[k, 0] for k ∈ 1:3])\n\njulia> # Bare symbols are not substituted\njulia> e = :(x0 * 2xf[3])\njulia> subs2(subs2(e, :x0, :x, 0), :xf, :x, :N)\n:(x0 * (2 * x[3, N]))\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTParser.subs2m","page":"Utils","title":"CTParser.subs2m","text":"subs2m(e, x, y, j; k) -> Any\n\n\nSubstitute x[i] or x[rg] in e for the midpoint scheme:\n\nx[i] → (y[i, j] + y[i, j + 1]) / 2 (scalar indexing)\nx[rg] → [(y[k, j] + y[k, j + 1]) / 2 for k ∈ rg] (range indexing)\n\nBare symbols like x (without indexing) are NOT substituted.\n\nSee also: subs2.\n\nExamples\n\njulia> e = :(x0[1] * 2xf[3] - cos(xf[2]) * 2x0[2])\n:(x0[1] * (2 * xf[3]) - cos(xf[2]) * (2 * x0[2]))\n\njulia> subs2m(subs2m(e, :x0, :x, 0), :xf, :x, :N)\n:(((x[1, 0] + x[1, 0 + 1]) / 2) * (2 * ((x[3, N] + x[3, N + 1]) / 2)) - cos((x[2, N] + x[2, N + 1]) / 2) * (2 * ((x[2, 0] + x[2, 0 + 1]) / 2)))\n\njulia> e = :(x0 * 2xf[3] - cos(xf) * 2x0[2])\n:(x0 * (2 * xf[3]) - cos(xf) * (2 * x0[2]))\n\njulia> subs2m(subs2m(e, :x0, :x, 0), :xf, :x, :N)\n:(x0 * (2 * ((x[3, N] + x[3, N + 1]) / 2)) - cos(xf) * (2 * ((x[2, 0] + x[2, 0 + 1]) / 2)))\n\njulia> e = :(x0[1:3])\n:(x0[1:3])\n\njulia> subs2m(e, :x0, :x, 0)\n:([((x[k, 0] + x[k, 0 + 1]) / 2) for k ∈ 1:3])\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTParser.subs3","page":"Utils","title":"CTParser.subs3","text":"subs3(e, x, y, i, j) -> Any\n\n\nSubstitute x[rg] by y[i, j], whatever rg, in e. (Note: rg is then expected to be used to loop on i.)\n\nExamples\n\njulia> e = :(x0[1:2:d] * 2xf[1:3])\n:(x0[1:2:d] * (2 * xf[1:3]))\n\njulia> subs3(e, :x0, :x, :i, 0)\n:(x[i, 0] * (2 * xf[1:3]))\n\njulia> subs3(e, :xf, :x, 1, :N)\n:(x0[1:2:d] * (2 * x[1, N]))\n\n\n\n\n\n","category":"function"},{"location":"onepass.html#Private-API","page":"Onepass","title":"Private API","text":"This page lists non-exported (internal) symbols of CTParser.\n\n","category":"section"},{"location":"onepass.html#From-CTParser","page":"Onepass","title":"From CTParser","text":"","category":"section"},{"location":"onepass.html#@def","page":"Onepass","title":"@def","text":"","category":"section"},{"location":"onepass.html#E_PREFIX","page":"Onepass","title":"E_PREFIX","text":"","category":"section"},{"location":"onepass.html#PREFIX_EXA","page":"Onepass","title":"PREFIX_EXA","text":"","category":"section"},{"location":"onepass.html#PREFIX_FUN","page":"Onepass","title":"PREFIX_FUN","text":"","category":"section"},{"location":"onepass.html#ParsingInfo","page":"Onepass","title":"ParsingInfo","text":"","category":"section"},{"location":"onepass.html#__init_aliases","page":"Onepass","title":"__init_aliases","text":"","category":"section"},{"location":"onepass.html#__throw","page":"Onepass","title":"__throw","text":"","category":"section"},{"location":"onepass.html#__wrap","page":"Onepass","title":"__wrap","text":"","category":"section"},{"location":"onepass.html#activate_backend","page":"Onepass","title":"activate_backend","text":"","category":"section"},{"location":"onepass.html#deactivate_backend","page":"Onepass","title":"deactivate_backend","text":"","category":"section"},{"location":"onepass.html#def_exa","page":"Onepass","title":"def_exa","text":"","category":"section"},{"location":"onepass.html#def_fun","page":"Onepass","title":"def_fun","text":"","category":"section"},{"location":"onepass.html#e_prefix","page":"Onepass","title":"e_prefix","text":"","category":"section"},{"location":"onepass.html#e_prefix!","page":"Onepass","title":"e_prefix!","text":"","category":"section"},{"location":"onepass.html#is_active_backend","page":"Onepass","title":"is_active_backend","text":"","category":"section"},{"location":"onepass.html#parse!","page":"Onepass","title":"parse!","text":"","category":"section"},{"location":"onepass.html#parsing","page":"Onepass","title":"parsing","text":"","category":"section"},{"location":"onepass.html#prefix_exa","page":"Onepass","title":"prefix_exa","text":"","category":"section"},{"location":"onepass.html#prefix_exa!","page":"Onepass","title":"prefix_exa!","text":"","category":"section"},{"location":"onepass.html#prefix_fun","page":"Onepass","title":"prefix_fun","text":"","category":"section"},{"location":"onepass.html#prefix_fun!","page":"Onepass","title":"prefix_fun!","text":"","category":"section"},{"location":"onepass.html#CTParser.@def","page":"Onepass","title":"CTParser.@def","text":"Define an optimal control problem. One pass parsing of the definition. Can be used writing either ocp = @def begin ... end or @def ocp begin ... end. In the second case, setting log to true will display the parsing steps.\n\nExample\n\nocp = @def begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend\n\n@def ocp begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend true # final boolean to show parsing log\n\n\n\n\n\n","category":"macro"},{"location":"onepass.html#CTParser.E_PREFIX","page":"Onepass","title":"CTParser.E_PREFIX","text":"Prefix reference for the error-handling backend used in generated code.\n\nThis Ref stores the symbol of the module that defines the ParsingError type used by __throw and __wrap.\n\n\n\n\n\n","category":"constant"},{"location":"onepass.html#CTParser.PREFIX_EXA","page":"Onepass","title":"CTParser.PREFIX_EXA","text":"Prefix reference for the ExaModels backend used in generated code.\n\nThis Ref stores the symbol of the module that implements the ExaModels backend targeted by @def when backend = :exa.\n\n\n\n\n\n","category":"constant"},{"location":"onepass.html#CTParser.PREFIX_FUN","page":"Onepass","title":"CTParser.PREFIX_FUN","text":"Prefix reference for the functional backend used in generated code.\n\nThis Ref stores the symbol of the module that implements the functional backend targeted by @def when backend = :fun.\n\n\n\n\n\n","category":"constant"},{"location":"onepass.html#CTParser.ParsingInfo","page":"Onepass","title":"CTParser.ParsingInfo","text":"mutable struct ParsingInfo\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"onepass.html#CTParser.__init_aliases","page":"Onepass","title":"CTParser.__init_aliases","text":"__init_aliases(\n;\n    max_dim\n) -> OrderedCollections.OrderedDict{Symbol, Union{Expr, Real, Symbol}}\n\n\nInitialise the dictionary of textual aliases for the parser.\n\nThis includes mappings such as R₁, R₂, … for powers of R, and ASCII fallbacks like <= → ≤, >= → ≥, => → →, etc.\n\n\n\n\n\n","category":"function"},{"location":"onepass.html#CTParser.__throw","page":"Onepass","title":"CTParser.__throw","text":"__throw(mess, n, line) -> Expr\n\n\nHelper to build a static ParsingError expression.\n\nThis is used for syntactic and semantic errors detected at macro expansion time. It formats the message with line information and wraps it in a throw(ParsingError(...)) expression using the current e_prefix.\n\n\n\n\n\n","category":"function"},{"location":"onepass.html#CTParser.__wrap","page":"Onepass","title":"CTParser.__wrap","text":"__wrap(e, n, line) -> Expr\n\n\nWrap a block of generated code with line-aware error reporting.\n\nThe returned expression executes e inside a try/catch block and, in case of an exception, prints the originating line number and source text before rethrowing.\n\n\n\n\n\n","category":"function"},{"location":"onepass.html#CTParser.activate_backend","page":"Onepass","title":"CTParser.activate_backend","text":"activate_backend(backend)\n\n\nActivate parsing backend. Possible choices: :exa.\n\n\n\n\n\n","category":"function"},{"location":"onepass.html#CTParser.deactivate_backend","page":"Onepass","title":"CTParser.deactivate_backend","text":"deactivate_backend(backend)\n\n\nDeactivate parsing backend. Possible choices: :exa.\n\n\n\n\n\n","category":"function"},{"location":"onepass.html#CTParser.def_exa","page":"Onepass","title":"CTParser.def_exa","text":"def_exa(e; log) -> Expr\n\n\nCore computation used to discretise, parsing an expression towards an ExaModels.ExaModel.\n\n\n\n\n\n","category":"function"},{"location":"onepass.html#CTParser.def_fun","page":"Onepass","title":"CTParser.def_fun","text":"def_fun(e; log) -> Expr\n\n\nCore computation of @def macro, parsing an expression towards a CTModels.Model.\n\n\n\n\n\n","category":"function"},{"location":"onepass.html#CTParser.e_prefix","page":"Onepass","title":"CTParser.e_prefix","text":"e_prefix() -> Symbol\n\n\nReturn the current error-handling backend prefix.\n\n\n\n\n\n","category":"function"},{"location":"onepass.html#CTParser.e_prefix!","page":"Onepass","title":"CTParser.e_prefix!","text":"e_prefix!(p)\n\n\nSet the error-handling backend prefix used in generated code.\n\n\n\n\n\n","category":"function"},{"location":"onepass.html#CTParser.is_active_backend","page":"Onepass","title":"CTParser.is_active_backend","text":"is_active_backend(backend) -> Bool\n\n\nCheck whether backend is active or not.\n\n\n\n\n\n","category":"function"},{"location":"onepass.html#CTParser.parse!","page":"Onepass","title":"CTParser.parse!","text":"parse!(p, p_ocp, e; log, backend) -> Any\n\n\nParse the expression e and update the ParsingInfo structure p.\n\nExample\n\nparse!(p, :p_ocp, :(v ∈ R, variable))\n\n\n\n\n\n","category":"function"},{"location":"onepass.html#CTParser.parsing","page":"Onepass","title":"CTParser.parsing","text":"parsing(s, backend) -> Function\n\n\nCall the primitive associated with symbol s (:alias, etc.) for the associated backend.\n\n\n\n\n\n","category":"function"},{"location":"onepass.html#CTParser.prefix_exa","page":"Onepass","title":"CTParser.prefix_exa","text":"prefix_exa() -> Symbol\n\n\nReturn the current ExaModels backend prefix.\n\n\n\n\n\n","category":"function"},{"location":"onepass.html#CTParser.prefix_exa!","page":"Onepass","title":"CTParser.prefix_exa!","text":"prefix_exa!(p)\n\n\nSet the ExaModels backend prefix used for generated code.\n\n\n\n\n\n","category":"function"},{"location":"onepass.html#CTParser.prefix_fun","page":"Onepass","title":"CTParser.prefix_fun","text":"prefix_fun() -> Symbol\n\n\nReturn the current functional backend prefix.\n\nThis is the symbol of the module that will be used for the functional backend when expanding @def with backend = :fun.\n\n\n\n\n\n","category":"function"},{"location":"onepass.html#CTParser.prefix_fun!","page":"Onepass","title":"CTParser.prefix_fun!","text":"prefix_fun!(p)\n\n\nSet the functional backend prefix.\n\nThis updates PREFIX_FUN, thereby changing which module is used as the functional backend for code generated by @def.\n\n\n\n\n\n","category":"function"}]
}
