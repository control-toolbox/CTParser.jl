var documenterSearchIndex = {"docs":
[{"location":"dev.html#Private-functions","page":"API","title":"Private functions","text":"","category":"section"},{"location":"dev.html#CTModels","page":"API","title":"CTModels","text":"","category":"section"},{"location":"dev.html#CTParser.CTParser","page":"API","title":"CTParser.CTParser","text":"CTParser module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDocStringExtensions\nMLStyle\nOrderedCollections\nParameters\nUnicode\n\nList of all the exported names:\n\n\n\n\n\n","category":"module"},{"location":"dev.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"dev.html","page":"API","title":"API","text":"Pages   = [\"dev.md\"]\nModules = [CTParser]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"dev.html#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"dev.html#CTParser.ParsingInfo","page":"API","title":"CTParser.ParsingInfo","text":"mutable struct ParsingInfo\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"dev.html#CTParser.activate_backend-Tuple{Any}","page":"API","title":"CTParser.activate_backend","text":"activate_backend(backend)\n\n\nActivate parsing backend. Possible choices: :exa.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.concat-Tuple{Any, Any}","page":"API","title":"CTParser.concat","text":"concat(e1, e2) -> Expr\n\n\nConcatenate two expressions without creating extra blocks (as Expr(:block, e1, e2) would do).\n\nExample\n\njulia> e1 = :(x = 1; y = 2)\nquote\n    x = 1\n    #= REPL[3]:1 =#\n    y = 2\nend\n\njulia> e2 = :(z = 3)\n:(z = 3)\n\njulia> concat(e1, e2)\nquote\n    x = 1\n    #= REPL[3]:1 =#\n    y = 2\n    z = 3\nend\n\njulia> concat(e1, e1)\nquote\n    x = 1\n    #= REPL[3]:1 =#\n    y = 2\n    x = 1\n    #= REPL[3]:1 =#\n    y = 2\nend\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.constraint_type-NTuple{7, Any}","page":"API","title":"CTParser.constraint_type","text":"constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u,\n    v\n) -> Union{Symbol, Tuple{Symbol, Any}}\n\n\nReturn the type constraint among :initial, :final, :boundary, :control_range, :control_fun, :state_range, :state_fun, :mixed, :variable_range, :variable_fun (:other otherwise), together with the appropriate value (range, updated expression...) Expressions like u(t0) where u is the control and t0 the initial time return :other.\n\nExample\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v\n\njulia> constraint_type(:( ẏ(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( ẋ(s) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( x(0)' ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(t)' ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( x(0) ), t, t0, tf, x, u, v)\n(:initial, nothing)\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)\n(:initial, 1)\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(tf) ), t, t0, tf, x, u, v)\n(:final, nothing)\nj\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)\n(:final, 1)\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)\n(:control_range, 1)\n\njulia> constraint_type(:( u(t) ), t, t0, tf, x, u, v)\n(:control_range, nothing)\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)\n:control_fun\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)\n(:state_range, 1)\n\njulia> constraint_type(:( x(t) ), t, t0, tf, x, u, v)\n(:state_range, nothing)\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:2:9)\n\njulia> constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:10)\n\njulia> constraint_type(:( v[2] ), t, t0, tf, x, u, v)\n(:variable_range, 2)\n\njulia> constraint_type(:( v ), t, t0, tf, x, u, v)\n(:variable_range, nothing)\n\njulia> constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)\n:variable_fun\njulia> constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)\n:variable_fun\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.deactivate_backend-Tuple{Any}","page":"API","title":"CTParser.deactivate_backend","text":"deactivate_backend(backend)\n\n\nDeactivate parsing backend. Possible choices: :exa.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.def_exa-Tuple{Any}","page":"API","title":"CTParser.def_exa","text":"def_exa(e; log) -> Expr\n\n\nCore computation used to discretise, parsing an expression towards an ExaModels.ExaModel.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.def_fun-Tuple{Any}","page":"API","title":"CTParser.def_fun","text":"def_fun(e; log) -> Expr\n\n\nCore computation of @def macro, parsing an expression towards a CTModels.Model.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.expr_it-Tuple{Any, Any, Any}","page":"API","title":"CTParser.expr_it","text":"expr_it(e, _Expr, f) -> Any\n\n\nExpr iterator: apply _Expr to nodes and f to leaves of the AST.\n\nExample\n\njulia> id(e) = expr_it(e, Expr, x -> x)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.has-Tuple{Any, Any, Any}","page":"API","title":"CTParser.has","text":"has(e, x, t) -> Union{Missing, Bool}\n\n\nReturn true if e contains a (...x...)(t) call.\n\nExample\n\njulia> e = :( ∫( x[1](t)^2 + 2*u(t) ) → min )\n:(∫((x[1])(t) ^ 2 + 2 * u(t)) → min)\n\njulia> has(e, :x, :t)\ntrue\n\njulia> has(e, :u, :t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.has-Tuple{Any, Any}","page":"API","title":"CTParser.has","text":"has(e, e1) -> Union{Missing, Bool}\n\n\nReturn true if e contains e1.\n\nExample\n\njulia> e = :( ∫( x[1](t)^2 + 2*u(t) ) → min )\n:(∫((x[1])(t) ^ 2 + 2 * u(t)) → min)\n\njulia> has(e, 2)\ntrue\n\njulia> has(e, :x)\ntrue\n\njulia> has(e, :min)\ntrue\n\njulia> has(e, :( x[1](t)^2 ))\ntrue\n\njulia> !has(e, :( x[1](t)^3 ))\ntrue\n\njulia> !has(e, 3)\ntrue\n\njulia> !has(e, :max)\ntrue\n\njulia> has(:x, :x)\ntrue\n\njulia> !has(:x, 2)\ntrue\n\njulia> !has(:x, :y)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.is_active_backend-Tuple{Any}","page":"API","title":"CTParser.is_active_backend","text":"is_active_backend(backend) -> Bool\n\n\nCheck whether backend is active or not.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.parse!-Tuple{Any, Any, Any}","page":"API","title":"CTParser.parse!","text":"parse!(p, p_ocp, e; log, backend) -> Any\n\n\nParse the expression e and update the ParsingInfo structure p.\n\nExample\n\nparse!(p, :p_ocp, :(v ∈ R, variable))\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.parsing-Tuple{Any, Any}","page":"API","title":"CTParser.parsing","text":"parsing(s, backend) -> Function\n\n\nCall the primitive associated with symbol s (:alias, etc.) for the associated backend.\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.replace_call-Tuple{Any, Symbol, Any, Any}","page":"API","title":"CTParser.replace_call","text":"replace_call(e, x::Symbol, t, y) -> Any\n\n\nReplace calls in e of the form (...x...)(t) by (...y...).\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2 ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2)\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}","page":"API","title":"CTParser.replace_call","text":"replace_call(e, x::Vector{Symbol}, t, y) -> Any\n\n\nReplace calls in e of the form (...x1...x2...)(t) by (...y1...y2...) for all symbols x1, x2... in the vector x.\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:((xx ^ 2)(t0) + uu[1])\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.subs-Tuple{Any, Union{Real, Symbol}, Any}","page":"API","title":"CTParser.subs","text":"subs(e, e1::Union{Real, Symbol}, e2) -> Any\n\n\nSubstitute expression e1 by expression e2 in expression e.\n\nExamples\n\njulia> e = :( ∫( r(t)^2 + 2u₁(t)) → min )\n:(∫(r(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> subs(e, :r, :( x[1] ))\n:(∫((x[1])(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> e = :( ∫( u₁(t)^2 + 2u₂(t)) → min )\n:(∫(u₁(t) ^ 2 + 2 * u₂(t)) → min)\n\njulia> for i ∈ 1:2\n       e = subs(e, Symbol(:u, Char(8320+i)), :( u[$i] ))\n       end; e\n:(∫((u[1])(t) ^ 2 + 2 * (u[2])(t)) → min)\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); subs(e, :( $x[1]($(t0)) ), :( $x0[1] ))\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.subs2-NTuple{4, Any}","page":"API","title":"CTParser.subs2","text":"subs2(e, x, y, j) -> Any\n\n\nSubstitute x[i] by y[i, j], whatever i, in e. See also: subs5.\n\nExamples\n\njulia> e = :(x0[1] * 2xf[3] - cos(xf[2]) * 2x0[2])\n:(x0[1] * (2 * xf[3]) - cos(xf[2]) * (2 * x0[2]))\n\njulia> subs2(subs2(e, :x0, :x, 0), :xf, :x, :N)\n:(x[1, 0] * (2 * x[3, N]) - cos(x[2, N]) * (2 * x[2, 0]))\n\njulia> e = :(x0 * 2xf[3] - cos(xf) * 2x0[2])\n:(x0 * (2 * xf[3]) - cos(xf) * (2 * x0[2]))\n\njulia> subs2(subs2(e, :x0, :x, 0), :xf, :x, :N)\n:(x0 * (2 * x[3, N]) - cos(xf) * (2 * x[2, 0]))\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.subs3-NTuple{5, Any}","page":"API","title":"CTParser.subs3","text":"subs3(e, x, y, i, j) -> Any\n\n\nSubstitute x[rg] by y[i, j], whatever rg, in e.\n\nExamples\n\njulia> e = :(x0[1:2:d] * 2xf[1:3])\n:(x0[1:2:d] * (2 * xf[1:3]))\n\njulia> subs3(e, :x0, :x, :i, 0)\n:(x[i, 0] * (2 * xf[1:3]))\n\njulia> subs3(e, :xf, :x, 1, :N)\n:(x0[1:2:d] * (2 * x[1, N]))\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.subs4-NTuple{4, Any}","page":"API","title":"CTParser.subs4","text":"subs4(e, x, y, i) -> Any\n\n\nSubstitute x[rg] by y[i], whatever rg, in e.\n\nExamples\n\njulia> e = :(v[1:2:d] * 2xf[1:3])\n:(v[1:2:d] * (2 * xf[1:3]))\n\njulia> subs4(e, :v, :v, :i)\n:(v[i] * (2 * xf[1:3]))\n\njulia> subs4(e, :xf, :xf, 1)\n:(v[1:2:d] * (2 * xf[1]))\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.subs5-NTuple{4, Any}","page":"API","title":"CTParser.subs5","text":"subs5(e, x, y, j) -> Any\n\n\nSubstitute x[i] by (y[i, j] + y[i, j + 1]) / 2, whatever i, in e. See also: subs2.\n\nExamples\n\njulia> e = :(x0[1] * 2xf[3] - cos(xf[2]) * 2x0[2])\n:(x0[1] * (2 * xf[3]) - cos(xf[2]) * (2 * x0[2]))\n\njulia> subs5(subs5(e, :x0, :x, 0), :xf, :x, :N)\n:(((x[1, 0] + x[1, 0 + 1]) / 2) * (2 * ((x[3, N] + x[3, N + 1]) / 2)) - cos((x[2, N] + x[2, N + 1]) / 2) * (2 * ((x[2, 0] + x[2, 0 + 1]) / 2)))\n\njulia> e = :(x0 * 2xf[3] - cos(xf) * 2x0[2])\n:(x0 * (2 * xf[3]) - cos(xf) * (2 * x0[2]))\n\njulia> subs5(subs5(e, :x0, :x, 0), :xf, :x, :N)\n:(x0 * (2 * ((x[3, N] + x[3, N + 1]) / 2)) - cos(xf) * (2 * ((x[2, 0] + x[2, 0 + 1]) / 2)))\n\n\n\n\n\n","category":"method"},{"location":"dev.html#CTParser.@def-Tuple{Any}","page":"API","title":"CTParser.@def","text":"Define an optimal control problem. One pass parsing of the definition. Can be used writing either ocp = @def begin ... end or @def ocp begin ... end. In the second case, setting log to true will display the parsing steps.\n\nExample\n\nocp = @def begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend\n\n@def ocp begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend true # final boolean to show parsing log\n\n\n\n\n\n","category":"macro"},{"location":"index.html#CTParser.jl","page":"Introduction","title":"CTParser.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTParser.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The root package is OptimalControl.jl which aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods, both on CPU and GPU.","category":"page"}]
}
